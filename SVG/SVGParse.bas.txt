Attribute VB_Name = "SVGParse";
Option Explicit;
Public Type pointD;
	x As double;
	y As double;
	noCut As byte;
End Type;

Public Type typLine;
	Points() As pointD;
	Fillable As bool; // Only works for closed paths

	ContainedBy As long; // ID to containing poly

	xCenter As double;
	yCenter As double;

	Optimized As bool;

	greyLevel As byte; // 0 to GREYLEVELS level of grey, higher is lighter

	LayerID As string;

	PathCode As string;

	LevelNumber As long; //How many levels deep is this

	isDel As bool; // Deleted on next iteration
End Type;

Public containList As new Scripting.Dictionary();

Public pData() As typLine;
Public currentLine As long;

Public layerInfo As new Scripting.Dictionary();


Public Const PI = 3.141592654;
Public GLOBAL_DPI As double;

Public EXPORT_EXTENTS_X As double, EXPORT_EXTENTS_Y As double;
Public LastExportPath As string;
Public CurrentFile As string;


Function parseSVG(inFile As string);

	ChilkatXml SVG = new ChilkatXml();
	ChilkatXml x = null;
	long i = 0;
	long j = 0;

	double realW = 0;
	double realH = 0;
	double realDPI = 0;

	string[] S = null;


//TODO: INSTANT C# TODO TASK: The following 'ReDim' could not be resolved. A possible reason may be that the object of the ReDim was not declared as an array.
	ReDim pData(0);
	currentLine = 0;

	realDPI = 90;

	SVG.LoadXmlFile inFile;

	if (SVG == null)
	{
		MsgBox "Could not load SVG";
		return;
	}


	//For i = 0 To SVG.childNodes.length - 1
	//    Set x = SVG.childNodes(i)
	//    If x.nodeName = "svg" Then Exit For
	//Next

	if (SVG.Tag == "svg")
	{

		//   width="8.5in"
		//   height="11in"
		//   viewBox="0 0 765.00001 990.00002"

		// Read these numbers to determine the scale of the data inside the file.
		// width and height are the real-world widths and heights
		// viewbox is how we're going to scale the numbers in the file (expressed in pixels) to the native units of this program, which is inches

		realW = Microsoft.VisualBasic.Conversion.Val(SVG.GetAttrValue("width"));
		// Read the unit
		switch (SVG.GetAttrValue("width").Replace(realW, "").ToLower())
		{
			case "in": // no conversion needed
			break;
			case "mm":
			case "": // convert from mm
				realW = realW / 25.4;
				break;
			case "cm": // convert from cm
				realW = realW / 2.54;

				break;
		}

		realH = Microsoft.VisualBasic.Conversion.Val(SVG.GetAttrValue("height"));
		// Read the unit
		switch (SVG.GetAttrValue("height").Replace(realH, "").ToLower())
		{
			case "in": // no conversion needed
			break;
			case "mm":
			case "": // convert from mm
				realH = realH / 25.4;
				break;
			case "cm": // convert from cm
				realH = realH / 2.54;
				break;
		}

		//MsgBox "Size in inches: " & realW & ", " & realH

		// The 'ViewBox' is how we scale an inch to a pixel.  The default is 90dpi but it may not be.

		string ttt = null;
		//ttt = InputBox("Detected with: " & realW & " inches.  Change it?", "Width", realW)
		//If ttt <> "" Then
		//    realW = Val(ttt)
		//End If


		S = SVG.GetAttrValue("viewBox").Split(' ');
		if (S.GetUpperBound(0) == 3)
		{
			// Get the width in pixels
			if (realW == 0)
			{
				realDPI = 300;
			}
			else
			{
				realDPI = Microsoft.VisualBasic.Conversion.Val(S[2]) / realW;
			}
		}


		if (realDPI == 1)
		{
			realDPI = 72;
		}

		//ttt = InputBox("Detected DPI: " & realDPI & ".  Change it?", "DPI")
		//If ttt <> "" Then
		//    realDPI = Val(ttt)
		//End If


		GLOBAL_DPI = realDPI;


		parseSVGKids SVG;
	}

	// Scale by the DPI
	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(i)
		object tempWith1 = pData(i);
		for (j = 1; j <= tempWith1.Points.GetUpperBound(0); j++)
		{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith2 variable must be corrected.
//ORIGINAL LINE: With .Points(j)
			object tempWith2 = tempWith1.Points[j];
			tempWith2.x = tempWith2.x / realDPI;
			tempWith2.y = tempWith2.y / realDPI;
		}
	}

// Fix the extents
	double minX = 0;
	double minY = 0;

	minX = 1000000;
	minY = 1000000;

	// Calculate the extents
	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith3 variable must be corrected.
//ORIGINAL LINE: With pData(i)
		object tempWith3 = pData(i);
		for (j = 1; j <= tempWith3.Points.GetUpperBound(0); j++)
		{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith4 variable must be corrected.
//ORIGINAL LINE: With .Points(j)
			object tempWith4 = tempWith3.Points[j];
			minX = Min(minX, tempWith4.x);
			minY = Min(minY, tempWith4.y);
		}
	}


	// Now fix the points by removing space at the left and top

	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith5 variable must be corrected.
//ORIGINAL LINE: With pData(i)
		object tempWith5 = pData(i);
		for (j = 1; j <= tempWith5.Points.GetUpperBound(0); j++)
		{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith6 variable must be corrected.
//ORIGINAL LINE: With .Points(j)
			object tempWith6 = tempWith5.Points[j];
			tempWith6.x = tempWith6.x - minX;
			tempWith6.y = tempWith6.y - minY;
		}
	}


}



public object parseSVGKids(ChilkatXml inEle)
{
	return parseSVGKids(inEle, Optional currentLayer As String);
}

//INSTANT C# NOTE: C# does not support optional parameters. Overloaded method(s) are created above.
//ORIGINAL LINE: Function parseSVGKids(inEle As ChilkatXml, Optional currentLayer As String)
public object parseSVGKids(ChilkatXml inEle, string currentLayer)
{
	object tempparseSVGKids = null;

	// Loop through my kids and figure out what to do!
	long i = 0;
	ChilkatXml x = null;
	long beforeLine = 0;
	long j = 0;

	double cX = 0;
	double cY = 0;
	double cW = 0;
	double cH = 0;

	long beforeGroup = 0;
	string layerName = null;

	if (currentLayer == "")
	{
		currentLayer = "BLANK";
	}


	Debug.Print "PARSING A KIDS:", currentLayer;


	Set x = inEle.FirstChild;
	while ( x != null)
	{

		//MsgBox X.nodeName

		switch (x.Tag.ToLower())
		{
			case "g": // g is GROUP
				beforeGroup = currentLine;

				// Is this group a layer?
				layerName = getAttr(x, "inkscape:label", "");
				if (layerName == "")
				{
					if ((getAttr(x, "id", "").ToUpper().IndexOf("layer".ToUpper(), 0) + 1) > 0)
					{
						layerName = getAttr(x, "id", "");
					}
				}

				if (layerName == "")
				{
					layerName = currentLayer;
				}

				//If layerName = "" Then layerName = getAttr(x, "id", "")

				tempparseSVGKids x, layerName;

				if (getAttr(x, "transform", "") != "")
				{
					// Transform these lines
					for (j = beforeGroup + 1; j <= currentLine; j++)
					{
						transformLine j, getAttr(x, "transform", "");
					}
				}

				break;
			case "switch": // stupid crap
				tempparseSVGKids x;

			// SHAPES
				break;
			case "rect":
			case "path":
			case "line":
			case "polyline":
			case "circle":
			case "polygon":
			case "ellipse":
				beforeLine = currentLine;

				switch (x.Tag.ToLower())
				{
					case "rect": // RECTANGLE

						newLine currentLayer;
						cX = Microsoft.VisualBasic.Conversion.Val(getAttr(x, "x", ""));
						cY = Microsoft.VisualBasic.Conversion.Val(getAttr(x, "y", ""));
						cW = Microsoft.VisualBasic.Conversion.Val(getAttr(x, "width", ""));
						cH = Microsoft.VisualBasic.Conversion.Val(getAttr(x, "height", ""));
						addPoint cX, cY;
						addPoint cX + cW, cY;
						addPoint cX + cW, cY + cH;
						addPoint cX, cY + cH;
						addPoint cX, cY;

						pData(currentLine).Fillable = true;

						break;
					case "path":

						// Parse the path.
						string thePath = null;
						thePath = getAttr(x, "d", "");
						if (x.GetAttrValue("fill") != "" & x.GetAttrValue("fill") != "none") // For some reason Illustrator doesn't close paths that are filled
						{
							if (thePath.Length > 0)
							{
								if (thePath.Substring(thePath.Length - 1).ToLower() == "z")
								{
									// ALready closed
								}
								else
								{
									thePath = thePath + "z";
								}
							}
						}

						parsePath thePath, currentLayer;




						break;
					case "line":
						// Add this line
						newLine currentLayer;
						addPoint Microsoft.VisualBasic.Conversion.Val(getAttr(x, "x1", "")), Microsoft.VisualBasic.Conversion.Val(getAttr(x, "y1", ""));
						addPoint Microsoft.VisualBasic.Conversion.Val(getAttr(x, "x2", "")), Microsoft.VisualBasic.Conversion.Val(getAttr(x, "y2", ""));

						break;
					case "polyline":
						newLine currentLayer;
						parsePolyLine getAttr(x, "points", "");

						break;
					case "polygon":
						newLine currentLayer;
						parsePolyLine getAttr(x, "points", "");

						pData(currentLine).Fillable = true;


						break;
					case "circle":
						// Draw a circle.
						newLine currentLayer;
						parseCircle Microsoft.VisualBasic.Conversion.Val(getAttr(x, "cx", "")), Microsoft.VisualBasic.Conversion.Val(getAttr(x, "cy", "")), Microsoft.VisualBasic.Conversion.Val(getAttr(x, "r", ""));

						break;
					case "ellipse": // Draw an ellipse
						newLine currentLayer;
						//   cx="245.46707"
						//   cy = "469.48389"
						//   rx = "13.131983"
						//   ry="14.142136" />

						parseEllipse Microsoft.VisualBasic.Conversion.Val(getAttr(x, "cx", "")), Microsoft.VisualBasic.Conversion.Val(getAttr(x, "cy", "")), Microsoft.VisualBasic.Conversion.Val(getAttr(x, "rx", "")), Microsoft.VisualBasic.Conversion.Val(getAttr(x, "ry", ""));
						break;
				}

				// Shape transformations
				if (getAttr(x, "transform", "") != "")
				{
					// Transform these lines
					for (j = beforeLine + 1; j <= currentLine; j++)
					{
						transformLine j, getAttr(x, "transform", "");
					}
				}
				break;
		}
		Set x = x.NextSibling;
	}



	return tempparseSVGKids;
}

public object parseCircle(double cX, double cY, double Radi)
{

	double A = 0;
	double x = 0;
	double y = 0;
	long rr = 0;

	rr = 2;
	if (Radi > 100)
	{
		rr = 1;
	}


	for (A = 0; A <= 360; A += rr)
	{

		x = Cos(A * (PI / 180)) * Radi + cX;
		y = Sin(A * (PI / 180)) * Radi + cY;

		addPoint x, y;


	}

	pData(currentLine).Fillable = true;

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}


public object parseEllipse(double cX, double cY, double RadiX, double RadiY)
{

	double A = 0;
	double x = 0;
	double y = 0;
	long rr = 0;

	rr = 2;
	if (RadiX > 100 | RadiY > 100)
	{
		rr = 1;
	}


	for (A = 0; A <= 360; A += rr)
	{

		x = Cos(A * (PI / 180)) * RadiX + cX;
		y = Sin(A * (PI / 180)) * RadiY + cY;

		addPoint x, y;

	}

	pData(currentLine).Fillable = true;

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object transformLine(long lineID, string transformText)
{

	// Parse the transform text
	long e = 0;
	long f = 0;
	long j = 0;

	string func = null;
	string @params = null;
	object pSplit = null;
	double Ang = 0;


//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(lineID)
	object tempWith1 = pData(lineID);

	e = (transformText.IndexOf("(", 0) + 1);
	if (e > 0)
	{
		func = transformText.Substring(0, e - 1);
		f = (transformText.IndexOf(")", e) + 1);
		if (f > 0)
		{
			@params = transformText.Substring(e, f - e - 1);
		}

		switch (func.ToLower())
		{
			case "translate":
					// Just move everything
				pSplit = @params.Split(',');

					// Translate is
					// [ 1  0  tx ]
					// [ 0  1  ty ]
					// [ 0  0  1  ]

				if (pSplit.GetUpperBound(0) == 0)
				{
					multiplyLineByMatrix lineID, 1, 0, 0, 1, Microsoft.VisualBasic.Conversion.Val(pSplit(0)), 0;
				}
				else
				{
					multiplyLineByMatrix lineID, 1, 0, 0, 1, Microsoft.VisualBasic.Conversion.Val(pSplit(0)), Microsoft.VisualBasic.Conversion.Val(pSplit(1));
				}

				break;
			case "matrix":
				pSplit = @params.Split(',');
				if (pSplit.GetUpperBound(0) == 0)
				{
					pSplit = @params.Split(' ');
				}
				multiplyLineByMatrix lineID, Microsoft.VisualBasic.Conversion.Val(pSplit(0)), Microsoft.VisualBasic.Conversion.Val(pSplit(1)), Microsoft.VisualBasic.Conversion.Val(pSplit(2)), Microsoft.VisualBasic.Conversion.Val(pSplit(3)), Microsoft.VisualBasic.Conversion.Val(pSplit(4)), Microsoft.VisualBasic.Conversion.Val(pSplit(5));

				break;
			case "rotate":

				pSplit = @params.Split(',');
				Ang = Deg2Rad(Microsoft.VisualBasic.Conversion.Val(pSplit(0)));

				multiplyLineByMatrix lineID, Cos(Ang), Sin(Ang), -Sin(Ang), Cos(Ang), 0, 0;

				break;
			case "scale": // scale(-1,-1)
				pSplit = @params.Split(',');
				if (pSplit.GetUpperBound(0) == 0)
				{
					pSplit = @params.Split(' ');
				}
				multiplyLineByMatrix lineID, Microsoft.VisualBasic.Conversion.Val(pSplit(0)), 0, 0, Microsoft.VisualBasic.Conversion.Val(pSplit(1)), 0, 0;


				break;
		}

	}

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object multiplyLineByMatrix(long polyID, double A, double b, double c, double D, double e, double f)
{
	// Miltiply a line/poly by a transformation matrix
	// [ A C E ]
	// [ B D F ]
	// [ 0 0 1 ]

	// http://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined
	//X1 = AX + CY + E
	//Y1 = BX + DY + F
	long j = 0;
	pointD oldPoint = null;

//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(polyID)
	object tempWith1 = pData(polyID);
	for (j = 1; j <= tempWith1.Points.GetUpperBound(0); j++)
	{
		oldPoint = tempWith1.Points[j];
		tempWith1.Points[j].x = (A * oldPoint.x) + (c * oldPoint.y) + e;
		tempWith1.Points[j].y = (b * oldPoint.x) + (D * oldPoint.y) + f;
	}

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object parsePolyLine(string inLine)
{
	// Parse a polyline
	long pos = 0;
	string char = null;
	string token1 = null;
	string token2 = null;
	string token3 = null;
	string token4 = null;
	double currX = 0;
	double currY = 0;
	inLine = inLine.Replace("\r", " ");
	inLine = inLine.Replace("\n", " ");

	pos = 1;
	while ( ! (pos > inLine.Length))
	{
		skipWhiteSpace inLine, pos;
		token1 = extractToken(ref inLine, ref pos);
		skipWhiteSpace inLine, pos;
		token2 = extractToken(ref inLine, ref pos);

		if (token1 != "" & token2 != "")
		{
			addPoint Microsoft.VisualBasic.Conversion.Val(token1), Microsoft.VisualBasic.Conversion.Val(token2);
		}
	}


	// Close the shape.
	if (pData(currentLine).Points.GetUpperBound(0) > 0)
	{
		addPoint (pData(currentLine).Points[1].x), (pData(currentLine).Points[1].y);
	}


	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object parsePath(string inPath, string currentLayer)
{




	// Parse an SVG path.
	long pos = 0;
	string char = null;
	string token1 = null;
	string token2 = null;
	string token3 = null;
	string token4 = null;
	string token5 = null;
	string token6 = null;
	string token7 = null;
	string token8 = null;


	bool isRelative = false;
	bool gotFirstItem = false;

	double currX = 0;
	double currY = 0;

	pointD pt0 = null;
	pointD pt1 = null;
	pointD pt2 = null;
	pointD pt3 = null;
	pointD pt4 = null;
	pointD pt5 = null;

	pointD ptPrevPoint = null;
	bool hasPrevPoint = false;






	double startX = 0;
	double startY = 0;

	double pInSeg = 0;
	string lastChar = null;



	//M209.1,187.65c-0.3-0.2-0.7-0.4-1-0.4c-0.3,0-0.7,0.2-0.9,0.4c-0.3,0.3-0.4,0.6-0.4,0.9c0,0.4,0.1,0.7,0.4,1
	//c0.2,0.2,0.6,0.4,0.9,0.4c0.3,0,0.7-0.2,1-0.4c0.2-0.3,0.3-0.6,0.3-1C209.4,188.25,209.3,187.95,209.1,187.65z

	// Get rid of enter presses
	inPath = inPath.Replace("\r", " ");
	inPath = inPath.Replace("\n", " ");
	inPath = inPath.Replace("\t", " ");

	// Start parsing
	pos = 1;
	while ( ! (pos > inPath.Length))
	{
		char = inPath.Substring(pos - 1, 1);
		pos = pos + 1;
		isRelative = false;

		switch (char)
		{
			case "M":
			case "m":
			case "L":
			case "l":
			case "C":
			case "c":
			case "V":
			case "v":
			case "A":
			case "a":
			case "H":
			case "h":
			case "S":
			case "s":
			case "Z":
			case "z":
			case "q":
			case "Q":
			case "T":
			case "t":
				// Accepted character.
				lastChar = char;
				break;
			case " ":

			break;
			default:
				// No accepted, must be a continuation.
				char = lastChar;
				if (char == "m") // Continuous moveto becomes lineto
				{
					char = "l";
				}
				if (char == "M") // Continuous moveto becomes lineto not relative
				{
					char = "L";
				}
				pos = pos - 1;
				break;
		}


		switch (char)
		{
			case " ": // Skip spaces

			break;
			case "M":
			case "m": // MOVE TO
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}


				// Extract two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set our "current" co-ordinates to this
				if (isRelative)
				{
					currX = currX + Microsoft.VisualBasic.Conversion.Val(token1);
					currY = currY + Microsoft.VisualBasic.Conversion.Val(token2);
				}
				else
				{
					currX = Microsoft.VisualBasic.Conversion.Val(token1);
					currY = Microsoft.VisualBasic.Conversion.Val(token2);
				}

				// Start a new line, since we moved
				//If Not isRelative Then
				newLine currentLayer;
				//pData(currentLine).PathCode = Right(inPath, Len(inPath) - pos)

				// Add the start point to this line
				addPoint currX, currY;


				pData(currentLine).PathCode = pData(currentLine).PathCode + "Move to " + currX + ", " + currY + System.Environment.NewLine;


				//If Not gotFirstItem Then
				startX = currX;
				startY = currY;
				gotFirstItem = true;
				hasPrevPoint = false;

				break;
			case "L":
			case "l": // LINE TO
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}


				// Extract two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set our "current" co-ordinates to this
				if (isRelative)
				{
					currX = currX + Microsoft.VisualBasic.Conversion.Val(token1);
					currY = currY + Microsoft.VisualBasic.Conversion.Val(token2);
				}
				else
				{
					currX = Microsoft.VisualBasic.Conversion.Val(token1);
					currY = Microsoft.VisualBasic.Conversion.Val(token2);
				}

				// Add this point to the line
				addPoint currX, currY;

				pData(currentLine).PathCode = pData(currentLine).PathCode + "Line to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;
				hasPrevPoint = false;

				break;
			case "V":
			case "v": // VERTICAL LINE TO
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}

				// Extract one co-ordinate
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);

				// Set our "current" co-ordinates to this
				if (isRelative)
				{
					currY = currY + Microsoft.VisualBasic.Conversion.Val(token1);
				}
				else
				{
					currY = Microsoft.VisualBasic.Conversion.Val(token1);
				}

				// Add this point to the line
				addPoint currX, currY;

				pData(currentLine).PathCode = pData(currentLine).PathCode + "Vertical to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;
				hasPrevPoint = false;

				break;
			case "H":
			case "h": // HORIZONTAL LINE TO
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}

				// Extract one co-ordinate
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);

				// Set our "current" co-ordinates to this
				if (isRelative)
				{
					currX = currX + Microsoft.VisualBasic.Conversion.Val(token1);
				}
				else
				{
					currX = Microsoft.VisualBasic.Conversion.Val(token1);
				}

				// Add this point to the line
				addPoint currX, currY;
				pData(currentLine).PathCode = pData(currentLine).PathCode + "Horiz to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;
				hasPrevPoint = false;

				break;
			case "A":
			case "a": // PARTIAL ARC TO
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}

					//(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+

				// Radii X and Y
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// X axis rotation
				skipWhiteSpace inPath, pos;
				token3 = extractToken(ref inPath, ref pos);

				// Large arc flag
				skipWhiteSpace inPath, pos;
				token4 = extractToken(ref inPath, ref pos);

				// Sweep flag
				skipWhiteSpace inPath, pos;
				token5 = extractToken(ref inPath, ref pos);

				// X and y
				skipWhiteSpace inPath, pos;
				token6 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token7 = extractToken(ref inPath, ref pos);

				// Start point
				pt0.x = currX;
				pt0.y = currY;

				// Set our "current" co-ordinates to this
				if (isRelative)
				{
					currX = currX + Microsoft.VisualBasic.Conversion.Val(token6);
					currY = currY + Microsoft.VisualBasic.Conversion.Val(token7);
				}
				else
				{
					currX = Microsoft.VisualBasic.Conversion.Val(token6);
					currY = Microsoft.VisualBasic.Conversion.Val(token7);
				}

				pt1.x = currX;
				pt1.y = currY;

				parseArcSegment Microsoft.VisualBasic.Conversion.Val(token1), Microsoft.VisualBasic.Conversion.Val(token2), Microsoft.VisualBasic.Conversion.Val(token3), pt0, pt1, (token4 == "1"), (token5 == "1");

				pData(currentLine).PathCode = pData(currentLine).PathCode + "Partial Arc to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;
				hasPrevPoint = false;

				break;
			case "C":
			case "c": // CURVE TO
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}

				pt0.x = currX;
				pt0.y = currY;

				// Extract two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 0
				pt1.x = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				pt1.y = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);


				// Extract next two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 1
				pt2.x = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				pt2.y = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);

				// Extract next two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 2
				currX = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				currY = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);
				pt3.x = currX;
				pt3.y = currY;

//
				pInSeg = getPinSeg(pt0, pt3);



				// Run the bezier code with 4 points
				AddBezier pInSeg, pt0, pt1, pt2, pt3;

				// Reflect this point about pt3

				ptPrevPoint = reflectAbout(pt2, pt3);
				hasPrevPoint = true;

				pData(currentLine).PathCode = pData(currentLine).PathCode + "Bezier to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;

				break;
			case "S":
			case "s": // CURVE TO with 3 points
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}

				pt0.x = currX;
				pt0.y = currY;

				// Extract two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 0
				pt1.x = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				pt1.y = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);

				// Extract next two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 1
				currX = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				currY = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);
				pt2.x = currX;
				pt2.y = currY;

				pInSeg = getPinSeg(pt0, pt2);


				if (! hasPrevPoint)
				{
					// Same as pt1
					ptPrevPoint = pt1;
				}

				AddBezier pInSeg, pt0, ptPrevPoint, pt1, pt2;

				ptPrevPoint = reflectAbout(pt1, pt2);
				hasPrevPoint = true;


				pData(currentLine).PathCode = pData(currentLine).PathCode + "3Bezier to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;

				break;
			case "Q":
			case "q": // Quadratic Bezier TO with 3 points
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}

				pt0.x = currX;
				pt0.y = currY;

				// Extract two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 0
				pt1.x = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				pt1.y = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);

				// Extract next two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 1
				currX = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				currY = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);
				pt2.x = currX;
				pt2.y = currY;

				pInSeg = getPinSeg(pt0, pt2);


				//If Not hasPrevPoint Then
				//    ' Same as pt1
				//    ptPrevPoint = pt1
				//End If

				AddQuadBezier pInSeg, pt0, pt1, pt2;

				ptPrevPoint = reflectAbout(pt1, pt2);
				hasPrevPoint = true;

				pData(currentLine).PathCode = pData(currentLine).PathCode + "3Bezier to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;

				break;
			case "T":
			case "t": // Quadratic Bezier TO with 3 points, but use reflection of last
				if (char.ToLower() == char) // Lowercase means relative co-ordinates
				{
					isRelative = true;
				}
				if (! gotFirstItem) //Relative not valid for first item
				{
					isRelative = false;
				}

				pt0.x = currX;
				pt0.y = currY;

				// Extract two co-ordinates
				skipWhiteSpace inPath, pos;
				token1 = extractToken(ref inPath, ref pos);
				skipWhiteSpace inPath, pos;
				token2 = extractToken(ref inPath, ref pos);

				// Set into point 0
				pt1.x = (isRelative ? currX : 0) + Microsoft.VisualBasic.Conversion.Val(token1);
				pt1.y = (isRelative ? currY : 0) + Microsoft.VisualBasic.Conversion.Val(token2);

				pInSeg = getPinSeg(pt0, pt1);



				if (! hasPrevPoint)
				{
					// Same as pt1
					ptPrevPoint = pt0; // SHOULD NEVER HAPPEN
				}

				AddQuadBezier pInSeg, pt0, ptPrevPoint, pt1;

				ptPrevPoint = reflectAbout(ptPrevPoint, pt1);
				hasPrevPoint = true;

				pData(currentLine).PathCode = pData(currentLine).PathCode + "3Bezier to " + currX + ", " + currY + System.Environment.NewLine;

				if (! gotFirstItem)
				{
					startX = currX;
					startY = currY;
				}
				gotFirstItem = true;

				break;
			case "z":
			case "Z":

				hasPrevPoint = false;

				// z means end the shape
				// Draw a line back to start of shape
				addPoint startX, startY;
				currX = startX;
				currY = startY;


				// Since this is a closed path, mark it as fillable.
				pData(currentLine).Fillable = true;

				//gotFirstItem = False


				pData(currentLine).PathCode = pData(currentLine).PathCode + "End Shape" + System.Environment.NewLine;



				break;
			default:
				Debug.Print "UNSUPPORTED PATH CODE: ", char;


				break;
		}
	}




	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object getPinSeg(pointD pStart, pointD pEnd)
{
	double D = 0;
	D = pointDistance(pStart, pEnd) / GLOBAL_DPI;
	//MsgBox "distance: " & D

	//Select Case d
	//    Case Is > 20
	//        getPinSeg = 0.1
	//    Case Is > 10
	//        getPinSeg = 0.2
	//    Case Is > 5
	//        getPinSeg = 0.25
	//    Case Else
	//        getPinSeg = 0.3
	//End Select


	// with a resolution of 500 dpi, the curve should be split into 500 segments per inch. so a distance of 1 should be 500 segments, which is 0.002
	double segments = 0;
	segments = 250 * D;



	return Max(0.01, 1 / segments);



}




public pointD reflectAbout(pointD ptReflect, pointD ptOrigin)
{
	pointD tempreflectAbout = null;
	// Reflect ptReflect 180 degrees around ptOrigin


	tempreflectAbout.x = (-(ptReflect.x - ptOrigin.x)) + ptOrigin.x;
	tempreflectAbout.y = (-(ptReflect.y - ptOrigin.y)) + ptOrigin.y;


	return tempreflectAbout;
}

public object parseArcSegment(double RX, double RY, double rotAng, pointD P1, pointD P2, bool largeArcFlag, bool sweepFlag)
{

	// Parse "A" command in SVG, which is segments of an arc
	// P1 is start point
	// P2 is end point

	pointD centerPoint = null;
	double Theta = 0;
	pointD P1Prime = null;
	pointD P2Prime = null;

	pointD CPrime = null;
	double Q = 0;
	double qTop = 0;
	double qBot = 0;
	double c = 0;

	double startAng = 0;
	double endAng = 0;
	double Ang = 0;
	double AngStep = 0;

	pointD tempPoint = null;
	double tempAng = 0;
	double tempDist = 0;



	double Theta1 = 0;
	double ThetaDelta = 0;


	// Turn the degrees of rotation into radians
	Theta = Deg2Rad(rotAng);

	// Calculate P1Prime
	P1Prime.x = (Cos(Theta) * ((P1.x - P2.x) / 2)) + (Sin(Theta) * ((P1.y - P2.y) / 2));
	P1Prime.y = (-Sin(Theta) * ((P1.x - P2.x) / 2)) + (Cos(Theta) * ((P1.y - P2.y) / 2));

	P2Prime.x = (Cos(Theta) * ((P2.x - P1.x) / 2)) + (Sin(Theta) * ((P2.y - P1.y) / 2));
	P2Prime.y = (-Sin(Theta) * ((P2.x - P1.x) / 2)) + (Cos(Theta) * ((P2.y - P1.y) / 2));

	qTop = (((System.Math.Pow(RX, 2))) * ((System.Math.Pow(RY, 2)))) - (((System.Math.Pow(RX, 2))) * ((System.Math.Pow(P1Prime.y, 2)))) - (((System.Math.Pow(RY, 2))) * ((System.Math.Pow(P1Prime.x, 2))));

	if (qTop < 0) // We've been given an invalid arc. Calculate the correct value.
	{

		c = Sqr((((System.Math.Pow(P1Prime.y, 2))) / ((System.Math.Pow(RY, 2)))) + (((System.Math.Pow(P1Prime.x, 2))) / ((System.Math.Pow(RX, 2)))));

		RX = RX * c;
		RY = RY * c;

		qTop = 0;
	}

	qBot = (((System.Math.Pow(RX, 2))) * ((System.Math.Pow(P1Prime.y, 2)))) + (((System.Math.Pow(RY, 2))) * ((System.Math.Pow(P1Prime.x, 2))));
	if (qBot != 0)
	{
	Q = Sqr((qTop) / (qBot));
	}
	else
	{
		Q = 0;
	}
	// Q is negative
	if (largeArcFlag == sweepFlag)
	{
		Q = -Q;
	}

	// Calculate Center Prime
	CPrime.x = 0;

	if (RY != 0)
	{
		CPrime.x = Q * ((RX * P1Prime.y) / RY);
	}
	if (RX != 0)
	{
		CPrime.y = Q * -((RY * P1Prime.x) / RX);
	}

	// Calculate center point
	centerPoint.x = ((Cos(Theta) * CPrime.x) - (Sin(Theta) * CPrime.y)) + ((P1.x + P2.x) / 2);
	centerPoint.y = ((Sin(Theta) * CPrime.x) + (Cos(Theta) * CPrime.y)) + ((P1.y + P2.y) / 2);

	// TEMPTEMP

	frmInterface.Zoom = 2;
	frmInterface.panX = 140;
	frmInterface.panY = 140;


	frmInterface.Picture1.Circle ((centerPoint.x + frmInterface.panX) * frmInterface.Zoom, (centerPoint.y + frmInterface.panY) * frmInterface.Zoom), 10, vbBlue;
	frmInterface.Picture1.Circle ((P1.x + frmInterface.panX) * frmInterface.Zoom, (P1.y + frmInterface.panY) * frmInterface.Zoom), 10, vbGreen;
	frmInterface.Picture1.Circle ((P2.x + frmInterface.panX) * frmInterface.Zoom, (P2.y + frmInterface.panY) * frmInterface.Zoom), 10, vbRed;

	Debug.Print "Circle";

	// Calculate Theta1

	Theta1 = angleFromPoint(P1Prime, CPrime);
	ThetaDelta = angleFromPoint(P2Prime, CPrime);

	Theta1 = Theta1 - PI;
	ThetaDelta = ThetaDelta - PI;

	//Theta1 = angleFromVect(((P1Prime.X - CPrime.X) / RX), ((P1Prime.Y - CPrime.Y) / RY), (P1Prime.X - CPrime.X), (P1Prime.Y - CPrime.Y))
	//ThetaDelta = angleFromVect(((-P1Prime.X - CPrime.X) / RX), ((-P1Prime.Y - CPrime.Y) / RY), (-P1Prime.X - CPrime.X), (-P1Prime.Y - CPrime.Y))

	//Theta1 = Theta1 - (PI / 2)
	//ThetaDelta = ThetaDelta - (PI / 2)

	//If Theta1 = ThetaDelta Then ThetaDelta = ThetaDelta + (PI * 2)

	//Debug.Print Theta1


	if (sweepFlag) // Sweep is going POSITIVELY
	{
		if (ThetaDelta < Theta1)
		{
			ThetaDelta = ThetaDelta + (PI * 2);
		}
	}
	else // Sweep is going NEGATIVELY
	{
		//If ThetaDelta < 0 Then ThetaDelta = ThetaDelta + (PI * 2)
		if (ThetaDelta > Theta1)
		{
			ThetaDelta = ThetaDelta - (PI * 2);
		}
	}


	startAng = Theta1;
	endAng = ThetaDelta;


	AngStep = (PI / 180);
	if (! sweepFlag) // Sweep flag indicates a positive step
	{
		AngStep = -AngStep;
	}

	Debug.Print "Start angle", Rad2Deg(startAng), " End angle ", Rad2Deg(endAng), "Step ", Rad2Deg(AngStep);

	//Theta = Deg2Rad(-40)

	// Hackhack
	//startAng = startAng + AngStep * 2


	Ang = startAng;
	do
	{
		// X   =   RX
		//pt4.X = (pt1.X * Cos(Ang))
		//pt4.Y = (pt1.Y * Sin(Ang))

		//pt4.X = (Cos(Theta) * pt4.X) + (-Sin(Theta) * pt4.Y)
		//pt4.Y = (Sin(Theta) * pt4.X) + (Cos(Theta) * pt4.Y)

		//         X      CX
		//pt4.X = pt4.X + pt3.X
		//pt4.Y = pt4.Y + pt3.Y

		tempPoint.x = (RX * Cos(Ang)) + centerPoint.x;
		tempPoint.y = (RY * Sin(Ang)) + centerPoint.y;

		tempAng = angleFromPoint(centerPoint, tempPoint) + Theta;
		tempDist = pointDistance(centerPoint, tempPoint);

		tempPoint.x = (tempDist * Cos(tempAng)) + centerPoint.x;
		tempPoint.y = (tempDist * Sin(tempAng)) + centerPoint.y;





		//tempPoint.X = (Cos(Theta) * tempPoint.X) + (-Sin(Theta) * tempPoint.Y)
		//tempPoint.Y = (Sin(Theta) * tempPoint.X) + (Cos(Theta) * tempPoint.Y)


		addPoint tempPoint.x, tempPoint.y;


		Ang = Ang + AngStep;
	} while ( ! ((Ang >= endAng && AngStep > 0) | (Ang <= endAng && AngStep < 0)));

	// Add the final point

	addPoint P2.x, P2.y;


	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public pointD rotatePoint(pointD inPoint, double Theta, pointD centerPoint)
{
	pointD temprotatePoint = null;

	temprotatePoint = inPoint;

	temprotatePoint.x = temprotatePoint.x - centerPoint.x;
	temprotatePoint.y = temprotatePoint.y - centerPoint.y;

	temprotatePoint.x = (Cos(Theta) * temprotatePoint.x) + (-Sin(Theta) * temprotatePoint.y);
	temprotatePoint.y = (Sin(Theta) * temprotatePoint.x) + (Cos(Theta) * temprotatePoint.y);

	temprotatePoint.x = temprotatePoint.x + centerPoint.x;
	temprotatePoint.y = temprotatePoint.y + centerPoint.y;



	return temprotatePoint;
}


public double Rad2Deg(double inRad)
{
	return inRad * (180 / PI);
}

public double Deg2Rad(double inDeg)
{
	return inDeg / (180 / PI);
}

public double angleFromVect(double vTop, double vBot, double diffX, double diffY)
{
	double tempangleFromVect = 0;
	// Not sure if this working

	if (vBot == 0)
	{
		tempangleFromVect = ((vTop > 0) ? PI / 2 : -PI / 2);
	}
	else if (diffX >= 0)
	{
		tempangleFromVect = Atn(vTop / vBot);
	}
	else
	{
		tempangleFromVect = Atn(vTop / vBot) - PI;
	}

	return tempangleFromVect;
}

public double angleFromPoint(pointD pCenter, pointD pPoint)
{
	double tempangleFromPoint = 0;
	// Calculate the angle of a point relative to the center

	// Slope is rise over run
	double slope = 0;

	if (pPoint.x == pCenter.x)
	{
		// Either 90 or 270
		tempangleFromPoint = ((pPoint.y > pCenter.y) ? PI / 2 : -PI / 2);

	}
	else if (pPoint.x > pCenter.x)
	{
		// 0 - 90 and 270-360
		slope = (pPoint.y - pCenter.y) / (pPoint.x - pCenter.x);
		tempangleFromPoint = Atn(slope);
	}
	else
	{
		// 180-270
		slope = (pPoint.y - pCenter.y) / (pPoint.x - pCenter.x);
		tempangleFromPoint = Atn(slope) + PI;
	}

	if (tempangleFromPoint < 0)
	{
		tempangleFromPoint = tempangleFromPoint + (PI * 2);
	}




	return tempangleFromPoint;
}


public object newLine()
{
	return newLine(Optional theLayer As String);
}

//INSTANT C# NOTE: C# does not support optional parameters. Overloaded method(s) are created above.
//ORIGINAL LINE: Function newLine(Optional theLayer As String)
public object newLine(string theLayer)
{
	currentLine = pData.GetUpperBound(0) + 1;
	// Set up this line
//TODO: INSTANT C# TODO TASK: The following 'ReDim' could not be resolved. A possible reason may be that the object of the ReDim was not declared as an array.
	ReDim Preserve pData(currentLine);
//TODO: INSTANT C# TODO TASK: The following 'ReDim' could not be resolved. A possible reason may be that the object of the ReDim was not declared as an array.
	ReDim pData(currentLine).Points[0];

	pData(currentLine).LayerID = theLayer;


	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}


public object addPoint(double x, double y)
{
	return addPoint(x, y, Optional noCutLineSegment As Boolean);
}

//INSTANT C# NOTE: C# does not support optional parameters. Overloaded method(s) are created above.
//ORIGINAL LINE: Function addPoint(x As Double, y As Double, Optional noCutLineSegment As Boolean)
public object addPoint(double x, double y, bool noCutLineSegment)
{

	long n = 0;
//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(currentLine)
	object tempWith1 = pData(currentLine);

	if (tempWith1.Points[tempWith1.Points.GetUpperBound(0)].x == x && tempWith1.Points[tempWith1.Points.GetUpperBound(0)].y == y && tempWith1.Points.GetUpperBound(0) > 0)
	{
			// No point to add
			//Debug.Print "same as last point"

	}
	else
	{
		n = tempWith1.Points.GetUpperBound(0) + 1;
//TODO: INSTANT C# TODO TASK: The following 'ReDim' could not be resolved. A possible reason may be that the object of the ReDim was not declared as an array.
		ReDim Preserve tempWith1.Points(n);
		tempWith1.Points[n].x = x;
		tempWith1.Points[n].y = y;
		if (noCutLineSegment)
		{
			tempWith1.Points[n].noCut = 1;
		}
	}


	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object skipWhiteSpace(ref string inPath, ref long pos)
{
	// Skip any white space.
	string char = null;

	while ( ! (pos > inPath.Length))
	{
		char = inPath.Substring(pos - 1, 1);
//INSTANT C# NOTE: The following VB 'Select Case' included range-type or non-constant 'Case' expressions and was converted to C# 'if-else' logic:
//		Select Case char
//ORIGINAL LINE: Case " ", ",", vbTab // List all white space characters here
		if ((char == " ") || (char == ",") || (char == "\t")) // List all white space characters here
		{
				// Continue
		}
//ORIGINAL LINE: Case Else
		else
		{
				return null;
		}

		pos = pos + 1;
	}
	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}


public string extractToken(ref string inPath, ref long pos)
{

	// Exract until we get a space or a comma
	string char = null;
	string build = null;
	bool seenMinus = false;
	long startPos = 0;
	bool seenE = false;

	startPos = pos;


	while ( ! (pos > inPath.Length))
	{
		char = inPath.Substring(pos - 1, 1);

		switch (char)
		{
			// Only accept numbers
			case "-":
				if (seenE)
				{
					build = build + char;
					pos = pos + 1;
				}
				else if (seenMinus || pos > startPos)
				{
//INSTANT C# WARNING: Exit statements not matching the immediately enclosing block are converted using a 'goto' statement:
//ORIGINAL LINE: Exit Do
					goto ExitLabel1;
				}
				else
				{
					// We already saw a minus sign
					seenMinus = true;
					build = build + char;
					pos = pos + 1;
				}

				break;
			case "0":
			case "1":
			case "2":
			case "3":
			case "4":
			case "5":
			case "6":
			case "7":
			case "8":
			case "9":
			case ".":
				build = build + char;
				pos = pos + 1;
				//,6.192 -10e-4,12.385
				break;
			case "e": // Exponent
				seenE = true;
				build = build + char;
				pos = pos + 1;
				break;
			default:
//INSTANT C# WARNING: Exit statements not matching the immediately enclosing block are converted using a 'goto' statement:
//ORIGINAL LINE: Exit Do
				goto ExitLabel1;
		}
	}
	ExitLabel1:
	return build;

}

public bool isNumChar(string char)
{
	bool tempisNumChar = false;
	switch (char)
	{
		// Only accept numbers
		case "0":
		case "1":
		case "2":
		case "3":
		case "4":
		case "5":
		case "6":
		case "7":
		case "8":
		case "9":
		case "-":
		case ".":
			tempisNumChar = true;
			break;
	}



	return tempisNumChar;
}



public object getAttr(ChilkatXml attr, string attrName)
{
	return getAttr(attr, attrName, Optional DefaultValue);
}

//INSTANT C# NOTE: C# does not support optional parameters. Overloaded method(s) are created above.
//ORIGINAL LINE: Function getAttr(attr As ChilkatXml, attrName As String, Optional DefaultValue)
public object getAttr(ChilkatXml attr, string attrName, object DefaultValue)
{

	return attr.GetAttrValue(attrName);

}

public object pointIsInPoly(long polyID, double x, double y)
{
	object temppointIsInPoly = null;

	// Determine if this point is inside the polygon.



	long i = 0;
	long j = 0;

//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(polyID)
	object tempWith1 = pData(polyID);
	j = tempWith1.Points.GetUpperBound(0);

	for (i = 1; i <= tempWith1.Points.GetUpperBound(0); i++)
	{

		if (tempWith1.Points[i].y < y & tempWith1.Points[j].y>= y || tempWith1.Points[j].y < y & tempWith1.Points[i].y>= y)
		{
				if (tempWith1.Points[i].x + (y - tempWith1.Points[i].y) / (tempWith1.Points[j].y - tempWith1.Points[i].y) * (tempWith1.Points[j].x - tempWith1.Points[i].x) < x)
				{
					temppointIsInPoly = ! temppointIsInPoly;
				}
		}

		j = i;
	}


//  int      i, j=polySides-1 ;
//  boolean  oddNodes=NO      ;
//
//  for (i=0; i<polySides; i++) {
//    if (polyY[i]<y && polyY[j]>=y
//    ||  polyY[j]<y && polyY[i]>=y) {
//      if (polyX[i]+(y-polyY[i])/(polyY[j]-polyY[i])*(polyX[j]-polyX[i])<x) {
//        oddNodes=!oddNodes; }}
//    j=i; }
//
//  return oddNodes; }


//    Dim nPol As Long
//    Dim i As Long, j As Long
//
//    Dim counter As Long
//
//    Dim p1 As pointD
//    Dim p2 As pointD
//    Dim p As pointD
//    Dim n As Long
//    Dim xinters As Double
//
//    p.X = X
//    p.Y = Y
//
//
//  'double xinters;
//  'Point p1,p2;
//    With pData(polyID)
//        n = UBound(.Points)
//        p1 = .Points(1)
//        For i = 1 To n
//            p2 = .Points(i Mod n)
//
//            If (p.Y > Min(p1.Y, p2.Y)) Then
//                If (p.Y <= Max(p1.Y, p2.Y)) Then
//                    If (p.X <= Max(p1.X, p2.X)) Then
//                        If (p1.Y <> p2.Y) Then
//                            xinters = (p.Y - p1.Y) * (p2.X - p1.X) / (p2.Y - p1.Y) + p1.X
//                            If (p1.X = p2.X Or p.X <= xinters) Then counter = counter + 1
//                        End If
//                    End If
//                End If
//            End If
//            p1 = p2
//        Next
//
//    End With
//
//    If counter Mod 2 = 0 Then
//        pointIsInPoly = False
//    Else
//        pointIsInPoly = True
//    End If
//
//



//    Dim Inside As Boolean
//
//    With pData(polyID)
//        nPol = UBound(.Points) ' Number of points
//
//        j = nPol ' Starts at the last point
//        For i = 1 To nPol
//            If .Points(j).Y - .Points(i).Y > 0 Then
//                If ((((.Points(i).Y <= Y) And (Y < .Points(j).Y)) Or _
//                    ((.Points(j).Y <= Y) And (Y < .Points(i).Y))) And _
//                    (X < (.Points(j).X - .Points(i).X) * (Y - .Points(i).Y) / (.Points(j).Y - .Points(i).Y) + .Points(i).X)) Then
//                        Inside = Not Inside
//                End If
//            End If
//            j = i
//        Next
//    End With
//
//    pointIsInPoly = Inside

//int pnpoly(int npol, float *xp, float *yp, float x, float y)
//    {
//      int i, j, c = 0;
//      for (i = 0, j = npol-1; i < npol; j = i++) {
//        if ((((yp[i] <= y) && (y < yp[j])) ||
//             ((yp[j] <= y) && (y < yp[i]))) &&
//            (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
//          c = !c;
//      }
//      return c;
//    }


	return temppointIsInPoly;
}

public object getPolyBounds(long polyID, ref double minX, ref double minY, ref double maxX, ref double maxY)
{

	long j = 0;

	minX = 1000000;
	minY = 1000000;
	maxX = 0;
	maxY = 0;

	// Calculate the extents
//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(polyID)
	object tempWith1 = pData(polyID);
	for (j = 1; j <= tempWith1.Points.GetUpperBound(0); j++)
	{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith2 variable must be corrected.
//ORIGINAL LINE: With .Points(j)
		object tempWith2 = tempWith1.Points[j];
		minX = Min(minX, tempWith2.x);
		minY = Min(minY, tempWith2.y);
		maxX = Max(maxX, tempWith2.x);
		maxY = Max(maxY, tempWith2.y);
	}


	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}


public object getExtents(ref double maxX, ref double maxY, ref double minX)
{
	double tempminY1 = Optional ByRef minY As double;
	return getExtents(ref maxX, ref maxY, ref minX, ref tempminY1);
}

public object getExtents(ref double maxX, ref double maxY)
{
	double tempminX2 = Optional ByRef minX As double;
	double tempminY3 = Optional ByRef minY As double;
	return getExtents(ref maxX, ref maxY, ref tempminX2, ref tempminY3);
}

//INSTANT C# NOTE: C# does not support optional parameters. Overloaded method(s) are created above.
//ORIGINAL LINE: Function getExtents(ByRef maxX As Double, ByRef maxY As Double, Optional ByRef minX As Double, Optional ByRef minY As Double)
public object getExtents(ref double maxX, ref double maxY, ref double minX, ref double minY)
{

	long i = 0;
	long j = 0;
	bool setMin = false;

	// Calculate the extents
	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith4 variable must be corrected.
//ORIGINAL LINE: With pData(i)
		object tempWith4 = pData(i);
		for (j = 1; j <= tempWith4.Points.GetUpperBound(0); j++)
		{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith5 variable must be corrected.
//ORIGINAL LINE: With .Points(j)
			object tempWith5 = tempWith4.Points[j];
			if (setMin)
			{
				minX = Min(minX, tempWith5.x);
				minY = Min(minY, tempWith5.y);
			}
			else
			{
				setMin = true;
				minX = tempWith5.x;
				minY = tempWith5.y;
			}
			maxX = Max(maxX, tempWith5.x);
			maxY = Max(maxY, tempWith5.y);
		}
	}


	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object canPolyFitInside(long smallPoly, long bigPoly)
{
	object tempcanPolyFitInside = null;
	// See if smallPoly will fit inside bigPoly

	// In theory, if all of smallPoly's points are inside bigPoly, then the whole poly is inside bigpoly.
	long i = 0;
//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(smallPoly)
	object tempWith1 = pData(smallPoly);
	for (i = 1; i <= tempWith1.Points.GetUpperBound(0); i++)
	{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith2 variable must be corrected.
//ORIGINAL LINE: With .Points(i)
		object tempWith2 = tempWith1.Points[i];
		if (! (pointIsInPoly(bigPoly, tempWith2.x, tempWith2.y)))
		{
					// This point is outside.
			return tempcanPolyFitInside;
		}
		else
		{
			tempcanPolyFitInside = true;
		}
	}



	return tempcanPolyFitInside;
}

public double getPolyArea(long polyID)
{
	// Get the area of this polygon
	double minX = 0;
	double maxX = 0;
	double minY = 0;
	double maxY = 0;

	getPolyBounds polyID, minX, minY, maxX, maxY;

	// For now, we are just using the bounding box. Todo: proper area calculation
	return (maxX - minX) * (maxY - minY);

}

public bool pointIsInPolyWithContain(long polyID, double x, double y)
{

	// Checks if the point is or isn't in the poly and deals with contained poly's also
	Microsoft.VisualBasic.Collection cl = null;
	long i = 0;
	bool isIn = false;
	if (containList.Exists(polyID)) // A list of polygons that I contain
	{
		Set cl = containList(polyID);
	}

	isIn = pointIsInPoly(polyID, x, y);

	// Check if it's in any of my kids. If so, it could be that it's NOT inside me.
	if (cl != null)
	{
		for (i = 1; i <= cl.count; i++)
		{
			if (pointIsInPolyWithContain(cl[i], x, y))
			{
				// It's in my kid.
			}
		}
	}

	return isIn;



}

public void rasterDocument(double yStep, string currentLayer)
{

	double maxX = 0;
	double maxY = 0;
	double minX = 0;
	double minY = 0;
	long p = 0;
	pointD[] totalResult = null;
	pointD[] result = null;
	long n = 0;
	double y = 0;
	long i = 0;
	bool goingRight = false;

	getExtents maxX, maxY, minX, minY;

	// Here's how this works:
	// We draw a line from left to right, and then right to left, through the entire document. All shapes.
	// We create a giant list of all the places where it intersects.
	// And we take that and create a single line with many on/off points.

	y = minY;
	while ( ! (y >= maxY))
	{

		totalResult = new pointD[1];

		for (p = 1; p <= pData.GetUpperBound(0); p++)
		{
			if (pData(p).ContainedBy == 0 && pData(p).Fillable)
			{



				// Draw a line from the X left to the X right, and fill in every second line segment.
				result = lineIntersectPoly(newPoint(minX - 50, y), newPoint(maxX + 50, y), p);


				if (result.GetUpperBound(0) > 0)
				{
					// Copy into TotalResult
					n = totalResult.GetUpperBound(0);
					Array.Resize(ref totalResult, n + result.GetUpperBound(0) + 1);
					for (i = 1; i <= result.GetUpperBound(0); i++)
					{
						totalResult[n + i] = result[i];
					}
				}

			}
		}

		if (totalResult.GetUpperBound(0) > 0)
		{

			newLine currentLayer;

			orderArray totalResult, goingRight;
			goingRight = ! goingRight; // TEMP

			i = 1;
			// Add a beginning point
			addPoint totalResult[i].x + (goingRight ? -0.5 : 0.5), totalResult[i].y, true;
			while (! (i > totalResult.GetUpperBound(0)))
			{
				// Start point
				addPoint totalResult[i].x, totalResult[i].y, i % 2 = 0;
				i = i + 1;
			}
			// And an end point
			addPoint totalResult[i - 1].x + (goingRight ? 0.5 : -0.5), totalResult[i - 1].y, true;

		}

		y = y + yStep;
		//    frmInterface.Caption = "Progress : " & Round(y / maxY * 100) & " %"
		//    DoEvents
		//'End If


	}




}

public void rasterLinePoly(long lineID, double yStep, string currentLayer)
{

	// Fill this polygon with raster lines from top to bottom

	double maxX = 0;
	double maxY = 0;
	double minX = 0;
	double minY = 0;
	double x = 0;
	double y = 0;
	double prevX = 0;
	double Xadd = 0;
	pointD[] result = null;
	pointD[] draw = null;

	long i = 0;
	long j = 0;
	pointD lastPoint = null;
	string cap = null;
	cap = frmInterface.Caption;



	bool goingRight = false; // The laser moves either left or right. Alternate directions smartly.

	//yStep = 0.008

	// Get the bounds of this shape.

	getPolyBounds lineID, minX, minY, maxX, maxY;

	y = minY;
	while ( ! (y >= maxY))
	{

		// Draw a line from the X left to the X right, and fill in every second line segment.
		result = lineIntersectPoly(newPoint(-10, y), newPoint(maxX + 50, y), lineID);

		if (result.GetUpperBound(0) > 0)
		{

			orderArray result, goingRight;
			goingRight = ! goingRight;
			i = 1;
			while (! (i > result.GetUpperBound(0)))
			{


				// Start point
				if (i + 1 <= result.GetUpperBound(0))
				{
					newLine currentLayer;
					addPoint result[i].x, result[i].y;
					addPoint result[i + 1].x, result[i + 1].y;
				}

				i = i + 2;
			}
		}
		//TEMP
		//yStep = yStep * 1.05
		y = y + yStep;

		//If CLng(Y) Mod 10 = 0 Then
			//frmInterface.Caption = "Progress : " & Round(y / maxY * 100) & " %"
			DoEvents;
		//End If

	}

}

public pointD[] lineThroughPolygon(long polyID, pointD startPoint, pointD endPoint)
{

	// Return an array of line segments to draw with this line
	pointD[] @out = null;
	pointD[] draw = null;
	pointD[] result = null;
	long i = 0;
	long j = 0;
	long K = 0;
	long k2 = 0;
	Microsoft.VisualBasic.Collection cl = null;
	if (containList.Exists(polyID)) // A list of polygons that I contain
	{
		Set cl = containList(polyID);
	}


	result = lineIntersectPoly(startPoint, endPoint, polyID);


	if (result.GetUpperBound(0) == 0) //No intersections
	{

		// Return just the segment unchanged
		@out = new pointD[2];
		@out[0] = startPoint;
		@out[1] = endPoint;
	}
	else
	{
		// Build a new set of lines based on the result.

		// Order the points from left to right
		orderArray result, true;

		// THIS array should be odd!
		@out = new pointD[1];

		@out[0] = startPoint;
		for (i = 1; i <= result.GetUpperBound(0); i += 2)
		{
			if (i + 1 <= result.GetUpperBound(0))
			{

				// Check the kids of this shape.
				if (cl != null)
				{
					for (K = 1; K <= 1; K++) //cl.count
					{
						draw = lineThroughPolygon(cl[K], result[i], result[i + 1]);

						// Add this
						for (k2 = 0; k2 <= draw.GetUpperBound(0); k2 += 2)
						{
							if (k2 + 1 <= draw.GetUpperBound(0))
							{
								Array.Resize(ref @out, @out.GetUpperBound(0) + 2 + 1);
								@out[@out.GetUpperBound(0) - 1] = draw[k2];
								@out[@out.GetUpperBound(0)] = draw[k2 + 1];
							}
						}
					}
				}
				else
				{
					// Add two points
					Array.Resize(ref @out, @out.GetUpperBound(0) + 2 + 1);
					@out[@out.GetUpperBound(0) - 1] = result[i];
					@out[@out.GetUpperBound(0)] = result[i + 1];
				}


			}
		}
		// Last point
		Array.Resize(ref @out, @out.GetUpperBound(0) + 2);
		@out[@out.GetUpperBound(0)] = endPoint;
	}


	return @out;

}

public object orderArray(pointD[] inRes, bool Ascending)
{

	// Order the return array of points.
	long i = 0;
	double b = 0;
	bool sorted = false;
	do
	{
		sorted = false;
		for (i = 1; i < inRes.GetUpperBound(0); i++)
		{

			if ((inRes[i].x > inRes[i + 1].x & ! Ascending) | (inRes[i].x < inRes[i + 1].x && Ascending))
			{
				// swap
				b = inRes[i].x;
				inRes[i].x = inRes[i + 1].x;
				inRes[i + 1].x = b;
				sorted = true;
			}
		}
	} while ( ! (! sorted));

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object sortByLayers()
{

	long i = 0;
	bool sorted = false;
	typLine bb = null;

	do
	{
		sorted = false;
		for (i = 1; i < pData.GetUpperBound(0); i++)
		{
			if (pData(i).LayerID > pData(i + 1).LayerID)
			{
				sorted = true;
				bb = pData(i + 1);
				pData(i + 1) = pData(i);
				pData(i) = bb;

			}
		}
	} while ( ! (sorted == false));

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object mergeConnectedLines()
{

	long i = 0;
	long j = 0;
	long n = 0;
	long iCount = 0;
	bool doMerge = false;
	bool doFlip = false;
	bool didMerge = false;

	// Looks for polygons that begin/end exactly at the beginning/end of another polygon and merges them into one polygon.

	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
		pData(i).Optimized = false;
	}

	// Step 2: Loop through the unoptimized polygons
	do
	{
		didMerge = false;
		for (i = 1; i < pData.GetUpperBound(0); i++)
		{


			if (! (pData(i).Optimized))
			{
				iCount = pData(i).Points.GetUpperBound(0);

				frmInterface.Caption = "Optimizing " + i + " / " + pData.GetUpperBound(0);
				if (i % 50 == 0)
				{
					DoEvents;
				}

				doMerge = false;
				for (j = 1; j <= pData.GetUpperBound(0); j++)
				{
					if (j != i && pData(j).LayerID == pData(i).LayerID)
					{
						if (pData(i).Points[iCount].x == pData(j).Points[1].x && pData(i).Points[iCount].y == pData(j).Points[1].y)
						{

							// OK, this shape starts where my shape ends.
							Debug.Print "SHAPE " + i + " AND " + j + " X: ", pData(i).Points[iCount].x, pData(j).Points[1].x;
							Debug.Print "SHAPE " + i + " AND " + j + " Y: ", pData(i).Points[iCount].y, pData(j).Points[1].y;

							doMerge = true;
							doFlip = false;
							break;
						}

						if (pData(i).Points[iCount].x == pData(j).Points[pData(j).Points.GetUpperBound(0)].x && pData(i).Points[iCount].y == pData(j).Points[pData(j).Points.GetUpperBound(0)].y)
						{
							// OK, this shape ends where my shape ends.
							doMerge = true;
							doFlip = true; // Since its the end that matched, we need to flip it first.
							break;
						}
					}
				}

				if (doMerge)
				{
					Debug.Print "MERGING SHAPE ", j, "INTO ", i;
					didMerge = true;
					if (doFlip) // Flip it around first.
					{
						flipPolyStartEnd j;
					}

					// Merge the points from j into i
//TODO: INSTANT C# TODO TASK: The following 'ReDim' could not be resolved. A possible reason may be that the object of the ReDim was not declared as an array.
					ReDim Preserve pData(i).Points[iCount + pData(j).Points.GetUpperBound(0)];

					for (n = 1; n <= pData(j).Points.GetUpperBound(0); n++)
					{
						pData(i).Points[iCount + n] = pData(j).Points[n];
					}
					// Delete shape j since we don't need it anymore
					for (n = j; n < pData.GetUpperBound(0); n++)
					{
						pData(n) = pData(n + 1);
					}
//TODO: INSTANT C# TODO TASK: The following 'ReDim' could not be resolved. A possible reason may be that the object of the ReDim was not declared as an array.
					ReDim Preserve pData(pData.GetUpperBound(0) - 1);

					// Then start the loop again.
					Debug.Print "COUNT IS NOW ", pData.GetUpperBound(0);
					break; // Start the loop again
				}
				else
				{
					// Alright we're done with this one
					pData(i).Optimized = true;
				}
			}
		}
	} while ( ! (! didMerge)); // Continue looping until there's no more merging

	// Finally, look for polygons that have a start and end point at the same co-ordinate and mark them as fillable.
	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(i)
		object tempWith1 = pData(i);
		if (tempWith1.Points[1].x == tempWith1.Points[tempWith1.Points.GetUpperBound(0)].x && tempWith1.Points[1].y == tempWith1.Points[tempWith1.Points.GetUpperBound(0)].y)
		{

					// End of shape matches start
					// Therefore it is fillable.
				tempWith1.Fillable = true;

		}
	}

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object optimizePolys()
{


	long i = 0;
	long j = 0;

	double dist = 0;
	double bestDist = 0;
	long bestLine = 0;
	bool bestIsEnd = false; // Is the best match actually the END of another line?


	// Run through the list of polygons. Order them so that when we reach the end of one,
	// we immediately find the nearest next line.

	// Step 1: Mark all of the polygons as "unordered"


	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
		pData(i).Optimized = false;
	}


	// Step 2: Loop through the unoptimized polygons
	for (i = 1; i < pData.GetUpperBound(0); i++)
	{
		if (pData(i).Optimized == false)
		{

			frmInterface.Caption = "Optimizing " + i + " / " + pData.GetUpperBound(0);
			if (i % 50 == 0)
			{
				DoEvents;
			}

			// Find the next polygon that ends nearest this one.
			bestDist = 10000000;
			bestLine = 0;


			for (j = 1; j <= pData.GetUpperBound(0); j++)
			{
				if (j != i && pData(j).Optimized == false && pData(j).LayerID == pData(i).LayerID)
				{
					// Calculate the distance
					dist = pointDistance(pData(i).Points[pData(i).Points.GetUpperBound(0)], pData(j).Points[1]);
					if (dist < bestDist)
					{
						 bestDist = dist;
						 bestLine = j;
						 bestIsEnd = false;
					}

					// Try the End of the line, since the line can be flipped if this makes more sense
					dist = pointDistance(pData(i).Points[pData(i).Points.GetUpperBound(0)], pData(j).Points[pData(j).Points.GetUpperBound(0)]);
					if (dist < bestDist)
					{
						 bestDist = dist;
						 bestLine = j;
						 bestIsEnd = true;
					}

				}
			}

			// Now we know which line is best to go NEXT.
			// So, move this line so that it is the next line after this one.
			if (bestLine > 0)
			{

				if (bestIsEnd)
				{
					// We've got to flip the line around, since it's END point is closest to our end.
					flipPolyStartEnd bestLine;
				}

				// For now, we just swap the desired line with the next one.
				SwapLine pData(i + 1), pData(bestLine);


			}

			//Mark ourselves as optimized
			pData(i).Optimized = true;

		}
	}

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public void SwapLine(ref typLine A, ref typLine b)
{
	typLine c = null;
	c = A;
	A = b;
	b = c;

}

public object exportGCODE(string outFile, double feedRate, bool PlungeZ, bool PPIMode, long PPIVal, bool LoopMode, long Loops, double RaiseDist)
{


	// Export GCODE!
	long i = 0;
	long j = 0;
	long f = 0;
	long scalar = 0;
	string tLayer = null;
	string t = null;


	long minFeedRate = 0;
	long maxFeedRate = 0;
	maxFeedRate = 200;
	minFeedRate = 15;


	f = FreeFile;
	// Draw the lines.

	if (Microsoft.VisualBasic.FileSystem.Dir(outFile, Microsoft.VisualBasic.FileAttribute.Normal) != "")
	{
		Kill outFile;
	}
	Open outFile For Append As f;


		// Get the extents
		double maxX = 0;
		double maxY = 0;

		double greyLevel = 0;

		bool isDefocused = false;
		bool wasDefocused = false;

		long cutCount = 0;
		long cuts = 0; // Defocusde cuts cut the same thing many times





		maxX = EXPORT_EXTENTS_X;
		maxY = EXPORT_EXTENTS_Y;


		// Make it 5 inches high
		scalar = 1;
		//scalar = 0.01


		// Go to the corners
		Print #f, "G20 (Units are in Inches)";
		Print #f, "F" + feedRate.ToString("0.00000");
		Print #f, "G61 (Go to exact corners)"; // Added Sep 21, 2016

		if (PPIMode)
		{
			Print #f, "S" + PPIVal + " (PPI mode with this many pulses per inch)";
		}

		if (LoopMode)
		{

			Print #f, "#201 = " + Loops + " (number of passes)";
			Print #f, "#200 = " + (RaiseDist * 0.0393701).ToString("0.000000") + " (move the bed up incrementally by this much in inches)";
			Print #f, "#300 = 0 (bed movement distance storage variable)";
			Print #f, "#100 = 1 (layer number storage variable)";

			Print #f, "G1 W0.00000 (make sure bed is 0.0000 before you cut first pass)";
			Print #f, "o101 WHILE [#100 LE #201] (the number of passes is that the number after LE, LE = less or equal to)";

		}


		// Turn on the spindle
		//Print #f, "M3 S1"

		//Print #F, "G1 X0 Y0"
		//Print #F, "G1 X" & Round(maxX * scalar, 5) & " Y0"
		//Print #F, "G1 X" & Round(maxX * scalar, 5) & " Y" & Round(maxY * scalar, 5)
		//Print #F, "G1 X0 Y" & Round(maxY * scalar, 5)

		tLayer = "---";

		for (i = 1; i <= pData.GetUpperBound(0); i++)
		{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith1 variable must be corrected.
//ORIGINAL LINE: With pData(i)
			object tempWith1 = pData(i);
			if (tempWith1.Points.GetUpperBound(0) > 0)
			{
					// Set the feed rate.
					//greyLevel = .greyLevel / GREYLEVELS
					//Print #f, "F" & CLng((maxFeedRate - minFeedRate) * greyLevel) + minFeedRate

				if (tempWith1.LayerID != "Cut Boxes")
				{

					if (tLayer != tempWith1.LayerID)
					{

						wasDefocused = isDefocused;
						isDefocused = false;
						if (layerInfo.Exists(tempWith1.LayerID))
						{

							if (layerInfo[tempWith1.LayerID].Exists("pausebefore"))
							{
								Print #f, "(MSG,Change Laser Power!)";
								Print #f, "M0";
							}

								// Are we defocused on this layer?
							if (layerInfo(tempWith1.LayerID).Exists("defocused"))
							{
								isDefocused = true;

									// Bring it down
								Print #1, "F100 (Increated feed rate for defocused cuts)";
								Print #1, "G0 W-" + layerInfo(tempWith1.LayerID)["defocused"];

							}

						}

						if (wasDefocused && ! isDefocused)
						{
								// Bring the W back up
							Print #1, "G0 W0";
								// Reset the feed rate
							Print #f, "F" + feedRate.ToString("0.00000");
						}

						tLayer = tempWith1.LayerID;
					}

					bool lastCutting = false;

					lastCutting = false;
					cutCount = 1;
					if (isDefocused)
					{
						cutCount = 20;
					}


					for (cuts = 1; cuts <= cutCount; cuts++)
					{

						for (j = 1; j <= tempWith1.Points.GetUpperBound(0); j++)
						{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith2 variable must be corrected.
//ORIGINAL LINE: With .Points(j)
							object tempWith2 = tempWith1.Points[j];

							if (j == 1) // First point, just GO there.
							{
								Print #f, "G0 X" + (tempWith2.x * scalar).ToString("0.00000") + " Y" + ((maxY - tempWith2.y) * scalar).ToString("0.00000");
										//Print #f, "G1 z-0.0010"

										// Turn on the spindle
								if (PPIMode)
								{
									Print #f, "M3";
								}
								else
								{
									Print #f, "M3 S1";
								}
										//Print #f, "G0 Z -0.0100"
							}
							else
							{
								t = "G1 X" + (tempWith2.x * scalar).ToString("0.00000") + " Y" + ((maxY - tempWith2.y) * scalar).ToString("0.00000");

										// Are we CUTTING to this point, or not?
								if (lastCutting && pData(i).Points[j - 1].noCut == 1)
								{

									if (PlungeZ)
									{
										Print #f, "G0 Z 0.2";
									}
									else
									{
										t = t + " M63 P0"; // STOP cutting
									}


									lastCutting = false;
								}
								else if (! lastCutting && pData(i).Points[j - 1].noCut == 0)
								{

									if (PlungeZ)
									{
										Print #f, "G0 Z -0.5";
									}
									else
									{
										t = t + " M62 P0"; // START cutting
									}

									lastCutting = true;
								}
								Print #f, t;
							}
						}

						if (isDefocused)
						{
								// Run the same line backwards again
							for (j = tempWith1.Points.GetUpperBound(0); j >= 1; j--)
							{
//TODO: INSTANT C# TODO TASK: The return type of the tempWith3 variable must be corrected.
//ORIGINAL LINE: With .Points(j)
								object tempWith3 = tempWith1.Points[j];
								if (j == pData(i).Points.GetUpperBound(0)) // First point, just GO there.
								{
									Print #f, "G0 X" + (tempWith3.x * scalar).ToString("0.00000") + " Y" + ((maxY - tempWith3.y) * scalar).ToString("0.00000");
								}
								else
								{
									t = "G1 X" + (tempWith3.x * scalar).ToString("0.00000") + " Y" + ((maxY - tempWith3.y) * scalar).ToString("0.00000");
									if (lastCutting && pData(i).Points[j - 1].noCut == 1)
									{
										t = t + " M63 P0"; // STOP cutting
										lastCutting = false;
									}
									else if (! lastCutting && pData(i).Points[j - 1].noCut == 0)
									{
										t = t + " M62 P0"; // START cutting
										lastCutting = true;
									}
									Print #f, t;
								}
							}
						}
					}

						//Print #F, "G0 Z0.0010"
						// Turn off the spindle
					Print #f, "M5";
					if (PlungeZ)
					{
						Print #f, "G0 Z 0.2";
					}

						//Print #f, "G0 Z 0.0100"

						//Print #f, "G1 Z0.0010"
					Print #f, "";
				}

			}

		}

		Print #f, "M5";
		if (PlungeZ)
		{
			Print #f, "G0 Z 0.2";
		}

		if (LoopMode)
		{
			Print #f, "#300 = [#200*#100]";
			Print #f, "G1 W#300 (move the bed up according to the layer its on)";
			Print #f, "#100 = [#100+1] (add one to the layer counter)";
			Print #f, "o101 ENDWHILE";
		}

		Print #f, "M30";
	Close #f;

	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}

public object MoveLayerToEnd(string LayerID)
{
	// Make a new list of just the lines not in this layer, then put these at the end

	typLine[] pNew = null;
	pNew = new typLine[1];
	long i = 0;
	long j = 0;
	long n = 0;
	for (i = 1; i <= pData.GetUpperBound(0); i++)
	{
		if (pData(i).LayerID == LayerID)
		{
			// Put this aside
			n = pNew.GetUpperBound(0) + 1;
			Array.Resize(ref pNew, n + 1);
			pNew[n] = pData(i);
		}
		else
		{
			j = j + 1;
			pData(j) = pData(i);
		}
	}

	// Now add to end
	for (i = 1; i <= n; i++)
	{
		j = j + 1;
		pData(j) = pNew[i];
	}

	// All done


	//INSTANT C# NOTE: Inserted the following 'return' since all code paths must return a value in C#:
	return null;
}